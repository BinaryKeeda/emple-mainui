{
  "title": "Reverse Words in a String",
  "description": "Given a string, reverse the order of the words. A word is a group of non-space characters. The final string should have exactly one space between words, and no leading or trailing spaces.",
  "metadata": {
    "difficulty": "Easy",
    "tags": ["String", "Two Pointers", "In-Place", "Text Processing"],
    "author": "Vaibhav Chauhan",
    "created_at": "2025-07-09",
    "updated_at": "2025-07-09",
    "source": "BinaryKeeda DSA Sheet"
  },
  "approaches": [
    {
      "category": "Brute Force",
      "algorithm": "Split + Reverse + Join",
      "description": "Use extra space to split the string by one or more spaces, reverse the list, and join with a single space.",
      "steps": [
        "Trim leading and trailing spaces using `trim()`.",
        "Split the string using regex `\\s+` to handle multiple spaces.",
        "Reverse the array of words.",
        "Join the words with a single space."
      ],
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "code": {
        "java": "import java.util.*;\n\nclass Solution {\n    public String reverseWords(String s) {\n        String[] words = s.trim().split(\"\\\\s+\");\n        Collections.reverse(Arrays.asList(words));\n        return String.join(\" \", words);\n    }\n}",
        "cpp": "#include <vector>\n#include <sstream>\n#include <algorithm>\n\nclass Solution {\npublic:\n    string reverseWords(string s) {\n        size_t start = s.find_first_not_of(\" \");\n        size_t end = s.find_last_not_of(\" \");\n        if (start == string::npos) return \"\";\n        string trimmed = s.substr(start, end - start + 1);\n\n        vector<string> words;\n        istringstream iss(trimmed);\n        string word;\n        while (iss >> word) {\n            words.push_back(word);\n        }\n\n        reverse(words.begin(), words.end());\n        ostringstream oss;\n        for (size_t i = 0; i < words.size(); ++i) {\n            if (i != 0) oss << \" \";\n            oss << words[i];\n        }\n        return oss.str();\n    }\n}"
      }
    },
    {
      "category": "Optimal",
      "algorithm": "In-Place Reversal",
      "description": "Trim, normalize spaces, reverse the entire string, then reverse each word individually.",
      "steps": [
        "Trim and normalize the spaces: remove leading, trailing, and reduce multiple spaces to one.",
        "Convert the cleaned string to a character array.",
        "Reverse the entire character array.",
        "Iterate through the array and reverse each word individually."
      ],
      "time_complexity": "O(n)",
      "space_complexity": "O(1) for C++, O(n) for Java",
      "code": {
        "java": "class Solution {\n    public String reverseWords(String s) {\n        String trimmed = s.trim().replaceAll(\"\\\\s+\", \" \");\n        char[] chars = trimmed.toCharArray();\n        reverse(chars, 0, chars.length - 1);\n\n        int start = 0;\n        for (int end = 0; end <= chars.length; end++) {\n            if (end == chars.length || chars[end] == ' ') {\n                reverse(chars, start, end - 1);\n                start = end + 1;\n            }\n        }\n\n        return new String(chars);\n    }\n\n    private void reverse(char[] arr, int left, int right) {\n        while (left < right) {\n            char temp = arr[left];\n            arr[left++] = arr[right];\n            arr[right--] = temp;\n        }\n    }\n}",
        "cpp": "class Solution {\npublic:\n    string reverseWords(string s) {\n        reverse(s.begin(), s.end());\n\n        int i = 0, j = 0, n = s.size();\n        while (i < n) {\n            while (i < n && s[i] == ' ') i++;\n            if (i == n) break;\n\n            int wordStart = j;\n            while (i < n && s[i] != ' ') s[j++] = s[i++];\n            reverse(s.begin() + wordStart, s.begin() + j);\n            if (i < n) s[j++] = ' ';\n        }\n\n        if (j > 0 && s[j-1] == ' ') j--;\n        s.resize(j);\n        return s;\n    }\n}"
      }
    }
  ],
  "examples": [
    {
      "input": "\"  life is beautiful  \"",
      "output": "\"beautiful is life\"",
      "explanation": "Extra spaces are trimmed and words are reversed."
    },
    {
      "input": "\"   coding   \"",
      "output": "\"coding\"",
      "explanation": "Single word with leading/trailing spaces."
    }
  ],
  "constraints": {
    "1 <= s.length <= 100000": true
  },
  "edge_cases": [
    {
      "input": "\"   \"",
      "output": "\"\"",
      "reason": "Only spaces should return an empty string."
    },
    {
      "input": "\"word\"",
      "output": "\"word\"",
      "reason": "Single word without spaces stays the same."
    },
    {
      "input": "\"a   b   c\"",
      "output": "\"c b a\"",
      "reason": "Multiple spaces are reduced to one."
    }
  ],
  "test_cases": [
    {
      "id": "tc1",
      "input": "\"the sky is blue\"",
      "expected_output": "\"blue is sky the\""
    },
    {
      "id": "tc2",
      "input": "\"  hello world  \"",
      "expected_output": "\"world hello\""
    }
  ],
  "notes": {
    "regex_note": "The regex `\\s+` is used to split the input string by one or more spaces.",
    "in_place_advantage": "In-place reversal is more efficient in terms of memory when allowed (C++)."
  },
  "hints": [
    "Can you split words without using extra space?",
    "What happens if you reverse the entire string first?",
    "Think about how to reverse individual words after the whole string is reversed."
  ],
  "follow_up": [
    "Can you implement the optimal approach using only O(1) extra space?",
    "How would you do this if the string was streamed word-by-word?",
    "Can you modify this to reverse characters of each word instead of word order?"
  ],
  "tags": ["String", "Text Processing", "Two Pointers", "Optimization"]
}
