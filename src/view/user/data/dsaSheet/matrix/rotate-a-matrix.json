{
  "title": "Rotate a Matrix",
  "description": "Given an N×N 2D array grid, rotate the elements 90 degrees clockwise in-place (without using additional storage space).",
  "metadata": {
    "difficulty": "Medium",
    "tags": ["Matrix", "In-place", "Rotation", "2D Array", "Layered Algorithm"],
    "author": "Vaibhav Chauhan",
    "created_at": "2025-07-09",
    "updated_at": "2025-07-09",
    "source": "BinaryKeeda DSA Sheet"
  },
  "approaches": [
    {
      "category": "Brute Force",
      "algorithm": "New Matrix Allocation",
      "description": "Create a new matrix and rotate elements by placing each element from (i,j) of original to (j, n-1-i) in new matrix, then copy it back.",
      "steps": [
        "Initialize an empty N×N matrix `rotated`.",
        "For every element at position (i, j) in the original matrix:",
        "Place it in position (j, N - 1 - i) in the new matrix.",
        "After filling, copy the rotated matrix back to the original matrix."
      ],
      "time_complexity": "O(N^2)",
      "space_complexity": "O(N^2)",
      "code": {
        "java": "class Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        int[][] rotated = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                rotated[j][n - 1 - i] = matrix[i][j];\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                matrix[i][j] = rotated[i][j];\n            }\n        }\n    }\n}",
        "cpp": "class Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        vector<vector<int>> rotated(n, vector<int>(n));\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                rotated[j][n - 1 - i] = matrix[i][j];\n            }\n        }\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                matrix[i][j] = rotated[i][j];\n            }\n        }\n    }\n};"
      }
    },
    {
      "category": "Optimal",
      "algorithm": "Layer-by-Layer In-place Rotation",
      "description": "Rotate the matrix layer-by-layer, performing swaps in groups of four to rotate elements in place without extra memory.",
      "steps": [
        "Loop through each layer from outermost to innermost (total of floor(N/2) layers).",
        "For each layer, identify the first and last index.",
        "For each element in the current layer, do the following in-place swaps:",
        "  - Save the top element.",
        "  - Move left element to top.",
        "  - Move bottom element to left.",
        "  - Move right element to bottom.",
        "  - Move saved top element to right.",
        "Repeat for all layers."
      ],
      "time_complexity": "O(N^2)",
      "space_complexity": "O(1)",
      "code": {
        "java": "class Solution {\n    public void rotate(int[][] matrix) {\n        int n = matrix.length;\n        for (int layer = 0; layer < n / 2; layer++) {\n            int first = layer;\n            int last = n - 1 - layer;\n            for (int i = first; i < last; i++) {\n                int offset = i - first;\n                int top = matrix[first][i];\n                matrix[first][i] = matrix[last - offset][first];\n                matrix[last - offset][first] = matrix[last][last - offset];\n                matrix[last][last - offset] = matrix[i][last];\n                matrix[i][last] = top;\n            }\n        }\n    }\n}",
        "cpp": "class Solution {\npublic:\n    void rotate(vector<vector<int>>& matrix) {\n        int n = matrix.size();\n        for (int layer = 0; layer < n / 2; layer++) {\n            int first = layer;\n            int last = n - 1 - layer;\n            for (int i = first; i < last; i++) {\n                int offset = i - first;\n                int top = matrix[first][i];\n                matrix[first][i] = matrix[last - offset][first];\n                matrix[last - offset][first] = matrix[last][last - offset];\n                matrix[last][last - offset] = matrix[i][last];\n                matrix[i][last] = top;\n            }\n        }\n    }\n};"
      }
    }
  ],
  "examples": [
    {
      "input": [
        ["A", "B", "C"],
        ["D", "E", "F"],
        ["G", "H", "I"]
      ],
      "output": [
        ["G", "D", "A"],
        ["H", "E", "B"],
        ["I", "F", "C"]
      ],
      "explanation": "Each layer rotated 90 degrees clockwise."
    },
    {
      "input": [
        [10, 20, 30, 40],
        [50, 60, 70, 80],
        [90, 100, 110, 120],
        [130, 140, 150, 160]
      ],
      "output": [
        [130, 90, 50, 10],
        [140, 100, 60, 20],
        [150, 110, 70, 30],
        [160, 120, 80, 40]
      ],
      "explanation": "Each outer and inner layer is rotated clockwise."
    }
  ],
  "constraints": {
    "1 <= N <= 1000": true,
    "matrix[i][j] can be integer or character": true,
    "matrix is square (NxN)": true
  },
  "edge_cases": [
    {
      "input": [[1]],
      "output": [[1]],
      "reason": "Single element matrix remains unchanged."
    },
    {
      "input": [
        [1, 2],
        [3, 4]
      ],
      "output": [
        [3, 1],
        [4, 2]
      ],
      "reason": "Smallest possible matrix with meaningful rotation."
    }
  ],
  "test_cases": [
    {
      "id": "tc1",
      "input": [
        [1, 2, 3],
        [4, 5, 6],
        [7, 8, 9]
      ],
      "expected_output": [
        [7, 4, 1],
        [8, 5, 2],
        [9, 6, 3]
      ]
    },
    {
      "id": "tc2",
      "input": [
        [5, 1],
        [2, 3]
      ],
      "expected_output": [
        [2, 5],
        [3, 1]
      ]
    }
  ],
  "notes": {
    "in_place": "The optimal method uses no extra space other than a few temporary variables.",
    "group_of_four": "Rotation is done by swapping four cells at a time per iteration."
  },
  "hints": [
    "Try visualizing the matrix as concentric square layers.",
    "In-place rotation requires 4-way element swapping.",
    "How can you rotate just the outermost square?"
  ],
  "follow_up": [
    "How would you rotate 90 degrees anti-clockwise?",
    "What changes are needed to rotate 180 degrees?",
    "Can this be applied to non-square matrices (MxN)?"
  ],
  "tags": ["Matrix", "In-place", "Rotation", "2D Array", "Layered Algorithm"]
}
