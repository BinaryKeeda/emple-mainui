{
  "title": "Fibonacci Number",
  "description": "Given an integer n, return the nth Fibonacci number where:\nF(0) = 0\nF(1) = 1\nF(n) = F(n - 1) + F(n - 2), for n > 1.",
  "metadata": {
    "difficulty": "Easy",
    "tags": ["Dynamic Programming", "Recursion", "Math", "DP", "Optimization"],
    "author": "Vaibhav Chauhan",
    "created_at": "2025-07-09",
    "updated_at": "2025-07-09",
    "source": "BinaryKeeda DSA Sheet"
  },
  "approaches": [
    {
      "category": "Brute Force",
      "algorithm": "Recursive Approach",
      "description": "A naive recursive solution that follows the mathematical recurrence relation directly.",
      "steps": [
        "If n == 0, return 0.",
        "If n == 1, return 1.",
        "Else, return fib(n - 1) + fib(n - 2)."
      ],
      "time_complexity": "O(2^n)",
      "space_complexity": "O(n)",
      "code": {
        "java": "class Solution {\n    public int fib(int n) {\n        if (n == 0) return 0;\n        if (n == 1) return 1;\n        return fib(n - 1) + fib(n - 2);\n    }\n}",
        "cpp": "class Solution {\npublic:\n    int fib(int n) {\n        if (n == 0) return 0;\n        if (n == 1) return 1;\n        return fib(n - 1) + fib(n - 2);\n    }\n};"
      }
    },
    {
      "category": "Optimal",
      "algorithm": "Dynamic Programming (Iterative)",
      "description": "An iterative bottom-up dynamic programming approach that eliminates redundant calculations.",
      "steps": [
        "If n == 0, return 0.",
        "If n == 1, return 1.",
        "Initialize: a = 0, b = 1.",
        "Iterate from i = 2 to n:",
        "  c = a + b",
        "  a = b, b = c",
        "Return b"
      ],
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "code": {
        "java": "class Solution {\n    public int fib(int n) {\n        if (n == 0) return 0;\n        if (n == 1) return 1;\n        int a = 0, b = 1, c;\n        for (int i = 2; i <= n; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n}",
        "cpp": "class Solution {\npublic:\n    int fib(int n) {\n        if (n == 0) return 0;\n        if (n == 1) return 1;\n        int a = 0, b = 1, c;\n        for (int i = 2; i <= n; i++) {\n            c = a + b;\n            a = b;\n            b = c;\n        }\n        return b;\n    }\n};"
      }
    }
  ],
  "examples": [
    {
      "input": 2,
      "output": 1,
      "explanation": "F(2) = F(1) + F(0) = 1 + 0 = 1"
    },
    {
      "input": 3,
      "output": 2,
      "explanation": "F(3) = F(2) + F(1) = 1 + 1 = 2"
    },
    {
      "input": 4,
      "output": 3,
      "explanation": "F(4) = F(3) + F(2) = 2 + 1 = 3"
    }
  ],
  "constraints": {
    "0 <= n <= 100000": true
  },
  "edge_cases": [
    {
      "input": 0,
      "output": 0,
      "reason": "Base case F(0)"
    },
    {
      "input": 1,
      "output": 1,
      "reason": "Base case F(1)"
    }
  ],
  "test_cases": [
    {
      "id": "tc1",
      "input": 5,
      "expected_output": 5
    },
    {
      "id": "tc2",
      "input": 10,
      "expected_output": 55
    }
  ],
  "notes": {
    "recursive_drawback": "The recursive method has exponential time complexity due to repeated calculations.",
    "dp_advantage": "Iterative DP uses constant space and computes results in linear time, making it optimal for large n."
  },
  "hints": [
    "Can you store the results of previous computations to avoid recalculating them?",
    "What if you use iteration instead of recursion?",
    "Is there a way to use constant space and still compute the result?"
  ],
  "follow_up": [
    "Can you implement this using memoization (top-down DP)?",
    "What if n is extremely large and you need to return result modulo 10^9+7?",
    "Can you compute F(n) in logarithmic time using matrix exponentiation?"
  ],
  "tags": [
    "Recursion",
    "Dynamic Programming",
    "Fibonacci",
    "Math",
    "Optimized Loop"
  ]
}
