{
  "title": "Power Function",
  "description": "Implement a function compute_power(base, exponent) that calculates base raised to the power of exponent (i.e., base^exponent). The function should efficiently handle both positive and negative exponents.",
  "metadata": {
    "difficulty": "Medium",
    "tags": [
      "Math",
      "Recursion",
      "Divide and Conquer",
      "Brute Force",
      "Exponentiation"
    ],
    "author": "Vaibhav Chauhan",
    "created_at": "2025-07-09",
    "updated_at": "2025-07-09",
    "source": "BinaryKeeda DSA Sheet"
  },
  "approaches": [
    {
      "category": "Brute Force",
      "algorithm": "Loop and Multiply/Divide",
      "description": "Use a simple loop to multiply the base with itself exponent times. Handle negative exponents by inverting the base.",
      "steps": [
        "If exponent is 0, return 1 (base^0 = 1).",
        "Convert exponent to long to avoid overflow (e.g., Integer.MIN_VALUE).",
        "If exponent is negative: invert base (base = 1/base) and negate exponent.",
        "Initialize result = 1.0.",
        "Loop from 1 to exponent and multiply result by base in each iteration.",
        "Return the result."
      ],
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "code": {
        "java": "class Solution {\n    public double myPow(double x, int n) {\n        if (n == 0) return 1.0;\n        long N = n;\n        if (N < 0) {\n            x = 1 / x;\n            N = -N;\n        }\n        double result = 1.0;\n        for (long i = 0; i < N; i++) {\n            result *= x;\n        }\n        return result;\n    }\n}",
        "cpp": "class Solution {\npublic:\n    double myPow(double x, int n) {\n        if (n == 0) return 1.0;\n        long N = n;\n        if (N < 0) {\n            x = 1 / x;\n            N = -N;\n        }\n        double result = 1.0;\n        for (long i = 0; i < N; i++) {\n            result *= x;\n        }\n        return result;\n    }\n};"
      }
    },
    {
      "category": "Optimal Approach",
      "algorithm": "Exponentiation by Squaring",
      "description": "Use divide-and-conquer method to calculate power in logarithmic time by squaring the base and halving the exponent.",
      "steps": [
        "If exponent is 0, return 1.",
        "Convert exponent to long to handle overflow.",
        "If exponent is negative: invert base and negate exponent.",
        "Initialize result = 1.0.",
        "While exponent > 0:",
        "- If exponent is odd, multiply result by base.",
        "- Square the base.",
        "- Halve the exponent.",
        "Return the final result."
      ],
      "time_complexity": "O(log n)",
      "space_complexity": "O(1)",
      "code": {
        "java": "class Solution {\n    public double myPow(double x, int n) {\n        if (n == 0) return 1.0;\n        long N = n;\n        if (N < 0) {\n            x = 1 / x;\n            N = -N;\n        }\n        double result = 1.0;\n        while (N > 0) {\n            if (N % 2 == 1) {\n                result *= x;\n            }\n            x *= x;\n            N /= 2;\n        }\n        return result;\n    }\n}",
        "cpp": "class Solution {\npublic:\n    double myPow(double x, int n) {\n        if (n == 0) return 1.0;\n        long N = n;\n        if (N < 0) {\n            x = 1 / x;\n            N = -N;\n        }\n        double result = 1.0;\n        while (N > 0) {\n            if (N % 2 == 1) {\n                result *= x;\n            }\n            x *= x;\n            N /= 2;\n        }\n        return result;\n    }\n};"
      }
    }
  ],
  "examples": [
    {
      "input": [3.0, 4],
      "output": 81.0,
      "explanation": "3^4 = 3×3×3×3 = 81"
    },
    {
      "input": [1.5, 3],
      "output": 3.375,
      "explanation": "1.5^3 = 1.5×1.5×1.5 = 3.375"
    },
    {
      "input": [5.0, -2],
      "output": 0.04,
      "explanation": "5^-2 = 1 / (5^2) = 1 / 25 = 0.04"
    }
  ],
  "constraints": {
    "base is a floating-point number": true,
    "exponent is a 32-bit signed integer": true,
    "if base == 0, exponent must not be negative": true
  },
  "edge_cases": [
    {
      "input": [2.0, 0],
      "output": 1.0,
      "reason": "Any number to the power 0 is 1"
    },
    {
      "input": [0.0, 5],
      "output": 0.0,
      "reason": "0 to any positive power is 0"
    },
    {
      "input": [0.0, -3],
      "output": "undefined",
      "reason": "0 to a negative power is undefined"
    }
  ],
  "test_cases": [
    {
      "id": "tc1",
      "input": [2.0, 10],
      "expected_output": 1024.0
    },
    {
      "id": "tc2",
      "input": [2.0, -3],
      "expected_output": 0.125
    }
  ],
  "notes": {
    "overflow_handling": "Converting exponent to long prevents overflow issues with Integer.MIN_VALUE.",
    "mathematical_principle": "Uses the property: x^n = x * x^(n-1), and x^n = (x^n/2)^2 for even n."
  },
  "hints": [
    "Try handling negative exponents first.",
    "Look into recursive or iterative squaring for optimization.",
    "Avoid recalculating power for the same values multiple times."
  ],
  "follow_up": [
    "Can you implement it recursively without stack overflow?",
    "Can you apply this to modular exponentiation?",
    "What if the exponent is a floating-point number (not just int)?"
  ],
  "tags": [
    "Math",
    "Power Function",
    "Logarithmic Optimization",
    "Edge Case Handling",
    "Exponentiation by Squaring"
  ]
}
