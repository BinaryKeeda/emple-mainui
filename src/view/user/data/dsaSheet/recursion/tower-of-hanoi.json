{
  "title": "Tower of Hanoi",
  "description": "Given k disks stacked in ascending order (smallest on top) on the source rod, determine the minimum number of moves required to transfer all disks to the destination rod using an auxiliary rod, following these rules: Only one disk can be moved at a time. A disk can only be placed on top of a larger disk.",
  "metadata": {
    "difficulty": "Medium",
    "tags": ["Recursion", "Mathematics", "Backtracking", "Divide and Conquer"],
    "author": "Vaibhav Chauhan",
    "created_at": "2025-07-09",
    "updated_at": "2025-07-09",
    "source": "BinaryKeeda DSA Sheet"
  },
  "approaches": [
    {
      "category": "Brute Force (Recursive)",
      "algorithm": "Recursive Tower of Hanoi",
      "description": "Recursively move (k-1) disks to the auxiliary rod, then move the largest disk to destination, and finally move the (k-1) disks from auxiliary to destination.",
      "steps": [
        "If k == 1: Move disk from source to destination and return 1.",
        "Recursively move (k - 1) disks from source to auxiliary using destination as helper.",
        "Move the kth (largest) disk from source to destination.",
        "Recursively move (k - 1) disks from auxiliary to destination using source as helper.",
        "Return total moves: 2 * moves for (k - 1) + 1."
      ],
      "time_complexity": "O(2^k)",
      "space_complexity": "O(k)",
      "code": {
        "java": "class Solution {\n    public int towerOfHanoi(int k, int from, int to, int aux) {\n        if (k == 1) {\n            return 1;\n        }\n        return towerOfHanoi(k - 1, from, aux, to) + 1 + towerOfHanoi(k - 1, aux, to, from);\n    }\n}",
        "cpp": "class Solution {\npublic:\n    int towerOfHanoi(int k, int from, int to, int aux) {\n        if (k == 1) {\n            return 1;\n        }\n        return towerOfHanoi(k - 1, from, aux, to) + 1 + towerOfHanoi(k - 1, aux, to, from);\n    }\n}"
      }
    },
    {
      "category": "Optimal (Mathematical Formula)",
      "algorithm": "2^k - 1",
      "description": "Use the formula 2^k - 1 to directly compute the minimum number of moves without recursion.",
      "steps": [
        "Input number of disks k.",
        "Compute 2 raised to the power k.",
        "Subtract 1 to get the total number of moves.",
        "Return the result."
      ],
      "time_complexity": "O(1)",
      "space_complexity": "O(1)",
      "code": {
        "java": "class Solution {\n    public int towerOfHanoi(int k, int from, int to, int aux) {\n        return (int) Math.pow(2, k) - 1;\n    }\n}",
        "cpp": "#include <cmath>\nclass Solution {\npublic:\n    int towerOfHanoi(int k, int from, int to, int aux) {\n        return pow(2, k) - 1;\n    }\n}"
      }
    }
  ],
  "examples": [
    {
      "input": {
        "k": 1,
        "source": "X",
        "destination": "Y",
        "auxiliary": "Z"
      },
      "output": 1,
      "explanation": "Move disk 1 from 'X' to 'Y'. Total moves = 1."
    },
    {
      "input": {
        "k": 2,
        "source": "A",
        "destination": "C",
        "auxiliary": "B"
      },
      "output": 3,
      "explanation": "Move disk 1 from 'A' to 'B'. Move disk 2 from 'A' to 'C'. Move disk 1 from 'B' to 'C'."
    }
  ],
  "constraints": {
    "0 <= k <= 20": true,
    "source and destination and auxiliary are distinct characters": true
  },
  "edge_cases": [
    {
      "input": {
        "k": 0,
        "source": "A",
        "destination": "B",
        "auxiliary": "C"
      },
      "output": 0,
      "reason": "No disks to move, so 0 moves."
    },
    {
      "input": {
        "k": 3,
        "source": "X",
        "destination": "Z",
        "auxiliary": "Y"
      },
      "output": 7,
      "reason": "2^3 - 1 = 7 moves for 3 disks."
    }
  ],
  "test_cases": [
    {
      "id": "tc1",
      "input": {
        "k": 4,
        "source": "A",
        "destination": "C",
        "auxiliary": "B"
      },
      "expected_output": 15
    },
    {
      "id": "tc2",
      "input": {
        "k": 0,
        "source": "A",
        "destination": "B",
        "auxiliary": "C"
      },
      "expected_output": 0
    }
  ],
  "notes": {
    "recursion_pattern": "Tower of Hanoi follows a classic divide-and-conquer strategy with the recurrence T(k) = 2T(k−1) + 1.",
    "formula_pattern": "For any k, total minimum moves = 2^k − 1 without recursion."
  },
  "hints": [
    "Can you move (k-1) disks to another rod and then come back to them after moving the largest disk?",
    "Do you notice a pattern in the number of moves? Try small values of k.",
    "Think recursively: solve smaller problems to build up to larger ones."
  ],
  "follow_up": [
    "Can you print the actual moves required for solving Tower of Hanoi?",
    "What happens if you add time delays or simulate real rods using stacks?",
    "How would the algorithm adapt if you had 4 rods instead of 3?"
  ],
  "tags": [
    "Recursion",
    "Divide and Conquer",
    "Mathematical Formula",
    "Classic Problems"
  ]
}
