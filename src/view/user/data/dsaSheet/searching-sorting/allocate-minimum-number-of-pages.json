{
  "title": "Allocate Minimum Pages",
  "description": "Allocate books such that the maximum number of pages assigned to a student is minimized. Books must be allocated contiguously and in order.",
  "metadata": {
    "difficulty": "Medium",
    "tags": ["Binary Search", "Greedy", "Array", "DP"],
    "author": "Vaibhav Chauhan",
    "created_at": "2025-07-09",
    "updated_at": "2025-07-09",
    "source": "BinaryKeeda DSA Sheet"
  },
  "approaches": [
    {
      "category": "Brute Force",
      "algorithm": "Recursive Backtracking",
      "description": "Try all possible contiguous splits of books into k parts recursively and track the minimum among the maximum allocations.",
      "steps": [
        "Base Case: If k == 1, assign all remaining books to one student.",
        "Try all valid positions to split books for the current student.",
        "Assign current subset to a student and solve the rest recursively for k-1 students.",
        "Track the max pages among all students for a given split.",
        "Return the minimum among all maximums."
      ],
      "time_complexity": "O(kⁿ)",
      "space_complexity": "O(n)",
      "code": {
        "java": "class Solution {\n    private int helper(int[] arr, int k, int start) {\n        if (k == 1) {\n            int sum = 0;\n            for (int i = start; i < arr.length; i++) sum += arr[i];\n            return sum;\n        }\n        int minMax = Integer.MAX_VALUE;\n        int sum = 0;\n        for (int i = start; i <= arr.length - k; i++) {\n            sum += arr[i];\n            int res = helper(arr, k - 1, i + 1);\n            minMax = Math.min(minMax, Math.max(sum, res));\n        }\n        return minMax;\n    }\n    public static int findPages(int[] arr, int k) {\n        if (k > arr.length) return -1;\n        Solution sol = new Solution();\n        return sol.helper(arr, k, 0);\n    }\n}",
        "cpp": "class Solution {\npublic:\n    int helper(vector<int>& arr, int k, int start) {\n        if (k == 1) return accumulate(arr.begin() + start, arr.end(), 0);\n        int minMax = INT_MAX, sum = 0;\n        for (int i = start; i <= arr.size() - k; i++) {\n            sum += arr[i];\n            int res = helper(arr, k - 1, i + 1);\n            minMax = min(minMax, max(sum, res));\n        }\n        return minMax;\n    }\n    int findPages(vector<int>& arr, int k) {\n        if (k > arr.size()) return -1;\n        return helper(arr, k, 0);\n    }\n}"
      }
    },
    {
      "category": "Optimal",
      "algorithm": "Binary Search + Greedy Allocation",
      "description": "Use binary search on the answer space (max pages) and check feasibility using greedy allocation.",
      "steps": [
        "Set low = max(arr), high = sum(arr).",
        "While low <= high, compute mid = (low + high) / 2.",
        "Use greedy strategy to check if books can be divided within k students such that no one exceeds mid pages.",
        "If feasible, update result and reduce high.",
        "Else, increase low.",
        "Return the final minimum maximum value."
      ],
      "time_complexity": "O(n log(sum))",
      "space_complexity": "O(1)",
      "code": {
        "java": "import java.util.Arrays;\nclass Solution {\n    private boolean isPossible(int[] arr, int k, int mid) {\n        int students = 1, sum = 0;\n        for (int pages : arr) {\n            if (sum + pages > mid) {\n                students++;\n                sum = pages;\n                if (students > k) return false;\n            } else {\n                sum += pages;\n            }\n        }\n        return true;\n    }\n    public static int findPages(int[] arr, int k) {\n        if (k > arr.length) return -1;\n        int low = Arrays.stream(arr).max().getAsInt();\n        int high = Arrays.stream(arr).sum();\n        int res = -1;\n        Solution sol = new Solution();\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (sol.isPossible(arr, k, mid)) {\n                res = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return res;\n    }\n}",
        "cpp": "class Solution {\npublic:\n    bool isPossible(vector<int>& arr, int k, int mid) {\n        int students = 1, sum = 0;\n        for (int pages : arr) {\n            if (sum + pages > mid) {\n                students++;\n                sum = pages;\n                if (students > k) return false;\n            } else {\n                sum += pages;\n            }\n        }\n        return true;\n    }\n    int findPages(vector<int>& arr, int k) {\n        if (k > arr.size()) return -1;\n        int low = *max_element(arr.begin(), arr.end());\n        int high = accumulate(arr.begin(), arr.end(), 0);\n        int res = -1;\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (isPossible(arr, k, mid)) {\n                res = mid;\n                high = mid - 1;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return res;\n    }\n}"
      }
    }
  ],
  "examples": [
    {
      "input": {
        "num": [10, 20, 30, 40],
        "k": 2
      },
      "output": 60,
      "explanation": "Optimal split is [10, 20, 30] and [40] with max pages 60."
    },
    {
      "input": {
        "num": [5, 10, 15],
        "k": 4
      },
      "output": -1,
      "explanation": "Cannot allocate to more students than books."
    }
  ],
  "constraints": {
    "1 <= num.length <= 10^5": true,
    "1 <= num[i] <= 10^6": true,
    "1 <= k <= 10^5": true
  },
  "edge_cases": [
    {
      "input": {
        "num": [10, 20, 30],
        "k": 1
      },
      "output": 60,
      "reason": "Only one student, so sum of all pages is the answer."
    },
    {
      "input": {
        "num": [10, 20, 30],
        "k": 3
      },
      "output": 30,
      "reason": "Each student gets one book."
    },
    {
      "input": {
        "num": [10, 20, 30],
        "k": 5
      },
      "output": -1,
      "reason": "Not enough books to assign at least one per student."
    }
  ],
  "test_cases": [
    {
      "id": "tc1",
      "input": {
        "num": [12, 34, 67, 90],
        "k": 2
      },
      "expected_output": 113
    },
    {
      "id": "tc2",
      "input": {
        "num": [10, 5, 30, 20],
        "k": 2
      },
      "expected_output": 35
    }
  ],
  "notes": {
    "greedy_strategy": "Allocate books to current student until next book causes overload (pages > mid), then assign to next student.",
    "binary_search_on_answer": "We are not searching elements, but the possible answer space between max(num) and sum(num)."
  },
  "hints": [
    "Can you split the problem into decision + search?",
    "Why can't you assign books non-contiguously?",
    "What’s the lower and upper bound for max pages?"
  ],
  "follow_up": [
    "What if book sizes change frequently?",
    "Can we optimize if number of students is also dynamic?",
    "How would you modify this if some books are optional?"
  ],
  "tags": ["Greedy", "Binary Search", "Array Partition", "Dynamic Programming"]
}
