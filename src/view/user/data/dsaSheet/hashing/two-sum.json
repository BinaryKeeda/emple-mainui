{
  "title": "Two Sum",
  "description": "Find the indices of two distinct elements in an array that add up to a given target sum. Each input is guaranteed to have exactly one solution, and the same element cannot be used twice.",
  "metadata": {
    "difficulty": "Easy",
    "tags": ["Array", "HashMap", "Brute Force", "Two Pointers"],
    "author": "Vaibhav Chauhan",
    "created_at": "2025-07-09",
    "updated_at": "2025-07-09",
    "source": "BinaryKeeda DSA Sheet"
  },
  "approaches": [
    {
      "category": "Brute Force",
      "algorithm": "Nested Loops",
      "description": "Loop through each element and check every pair to find two indices whose values sum to the target.",
      "steps": [
        "Loop through array with index i from 0 to n-1.",
        "For each i, loop through index j from i+1 to n-1.",
        "Check if values[i] + values[j] == target.",
        "If true, return [i, j]."
      ],
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)",
      "code": {
        "java": "class Solution {\n    public int[] twoSum(int[] nums, int target) {\n        int n = nums.length;\n        for(int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                if(nums[i] + nums[j] == target) {\n                    return new int[] {i, j};\n                }\n            }\n        }\n        return new int[] {}; // Will not reach here due to guaranteed solution\n    }\n}",
        "cpp": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        int n = nums.size();\n        for(int i = 0; i < n; i++) {\n            for(int j = i + 1; j < n; j++) {\n                if(nums[i] + nums[j] == target) {\n                    return {i, j};\n                }\n            }\n        }\n        return {}; // Won’t be reached since problem guarantees one solution\n    }\n}"
      }
    },
    {
      "category": "Optimal",
      "algorithm": "HashMap (Dictionary) Lookup",
      "description": "Use a HashMap to store visited values and their indices. For each element, check if its complement exists in the map.",
      "steps": [
        "Initialize an empty HashMap to store numbers and their indices.",
        "Loop through the array with index i.",
        "Compute complement = target - nums[i].",
        "If complement exists in map, return [map[complement], i].",
        "Else, insert nums[i] with its index i into the map."
      ],
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "code": {
        "java": "import java.util.HashMap;\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        HashMap<Integer, Integer> numMap = new HashMap<>();\n        for(int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if(numMap.containsKey(complement)) {\n                return new int[] {numMap.get(complement), i};\n            }\n            numMap.put(nums[i], i);\n        }\n        return new int[] {};\n    }\n}",
        "cpp": "class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> num_map;\n        for(int i = 0; i < nums.size(); i++) {\n            int complement = target - nums[i];\n            if(num_map.find(complement) != num_map.end()) {\n                return {num_map[complement], i};\n            }\n            num_map[nums[i]] = i;\n        }\n        return {};\n    }\n}"
      }
    }
  ],
  "examples": [
    {
      "input": {
        "values": [15, 7, 11, 2],
        "target_sum": 9
      },
      "output": [1, 3],
      "explanation": "7 (index 1) + 2 (index 3) = 9"
    },
    {
      "input": {
        "values": [30, 10, 40, 20],
        "target_sum": 60
      },
      "output": [2, 3],
      "explanation": "40 (index 2) + 20 (index 3) = 60"
    },
    {
      "input": {
        "values": [5, 5],
        "target_sum": 10
      },
      "output": [0, 1],
      "explanation": "5 (index 0) + 5 (index 1) = 10"
    }
  ],
  "constraints": {
    "1 <= values.length <= 10^4": true,
    "-10^9 <= values[i] <= 10^9": true,
    "-10^9 <= target_sum <= 10^9": true
  },
  "edge_cases": [
    {
      "input": {
        "values": [0, 4, 3, 0],
        "target_sum": 0
      },
      "output": [0, 3],
      "reason": "Two zeroes at index 0 and 3 sum to 0"
    },
    {
      "input": {
        "values": [-3, 4, 3, 90],
        "target_sum": 0
      },
      "output": [0, 2],
      "reason": "-3 and 3 add to 0"
    }
  ],
  "test_cases": [
    {
      "id": "tc1",
      "input": {
        "values": [1, 2, 3],
        "target_sum": 5
      },
      "expected_output": [1, 2]
    },
    {
      "id": "tc2",
      "input": {
        "values": [10, -2, 5, 7],
        "target_sum": 5
      },
      "expected_output": [0, 1]
    }
  ],
  "notes": {
    "hashmap_idea": "HashMap helps reduce time complexity by checking complements in constant time.",
    "guaranteed_solution": "You can safely return on first match because input guarantees exactly one solution."
  },
  "hints": [
    "What if you store the value along with its index as you iterate?",
    "How can you avoid using the same index twice?",
    "Use a map to store previous values seen and check if complement exists."
  ],
  "follow_up": [
    "Can you return all pairs if multiple solutions are allowed?",
    "What if you must return the pair with the smallest indices?",
    "What if the array is sorted — can a two-pointer approach work then?"
  ],
  "tags": [
    "HashMap",
    "Array",
    "Two Pointers",
    "Basic Algorithms",
    "Lookup Table"
  ]
}
