{
  "title": "K Different Pairs",
  "description": "Given an integer array and a non-negative integer target_diff, find the count of unique pairs (i, j) such that the absolute difference between values[i] and values[j] is equal to target_diff, with i ≠ j. Pairs with the same values in different orders should only be counted once. When target_diff is 0, count unique identical value pairs.",
  "metadata": {
    "difficulty": "Medium",
    "tags": ["Hashing", "Two Pointers", "Brute Force", "Array", "Set"],
    "author": "Vaibhav Chauhan",
    "created_at": "2025-07-09",
    "updated_at": "2025-07-09",
    "source": "BinaryKeeda DSA Sheet"
  },
  "approaches": [
    {
      "category": "Brute Force",
      "algorithm": "Nested Loops with Set",
      "description": "Use two nested loops to compare each pair of values. Use a set to store valid unique pairs with the required absolute difference to avoid duplicates.",
      "steps": [
        "Initialize a set to store seen unique pairs as sorted tuples.",
        "Loop through all i from 0 to n-1.",
        "Loop through all j from i+1 to n-1.",
        "Check if absolute difference between nums[i] and nums[j] equals target_diff.",
        "If true, store the pair (min, max) in the set.",
        "Return the size of the set."
      ],
      "time_complexity": "O(n^2)",
      "space_complexity": "O(n)",
      "code": {
        "java": "import java.util.*;\n\nclass Solution {\n    public int findPairs(int[] nums, int k) {\n        Set<String> seen = new HashSet<>();\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (Math.abs(nums[i] - nums[j]) == k) {\n                    int a = Math.min(nums[i], nums[j]);\n                    int b = Math.max(nums[i], nums[j]);\n                    seen.add(a + \":\" + b);\n                }\n            }\n        }\n        return seen.size();\n    }\n}",
        "cpp": "#include <vector>\n#include <set>\n#include <cmath>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findPairs(vector<int>& nums, int k) {\n        set<pair<int, int>> uniquePairs;\n        int n = nums.size();\n        for(int i = 0; i < n; ++i) {\n            for(int j = i + 1; j < n; ++j) {\n                if (abs(nums[i] - nums[j]) == k) {\n                    int a = min(nums[i], nums[j]);\n                    int b = max(nums[i], nums[j]);\n                    uniquePairs.insert({a, b});\n                }\n            }\n        }\n        return uniquePairs.size();\n    }\n};"
      }
    },
    {
      "category": "Optimal Approach",
      "algorithm": "Hashing with Set and Frequency Map",
      "description": "Use a HashSet to track seen numbers and a HashMap to count frequencies. Based on target_diff value, handle zero-difference and non-zero cases separately.",
      "steps": [
        "If target_diff < 0, return 0 (invalid input).",
        "If target_diff == 0:",
        "- Build a frequency map for all numbers.",
        "- Count keys where frequency ≥ 2 (identical value pairs).",
        "If target_diff > 0:",
        "- Store all numbers in a set.",
        "- For each number in the set, check if num + k exists.",
        "- Count such valid pairs.",
        "Return the total count."
      ],
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "code": {
        "java": "import java.util.*;\n\nclass Solution {\n    public int findPairs(int[] nums, int k) {\n        if (k < 0) return 0;\n\n        Set<Integer> seen = new HashSet<>();\n        Set<Integer> uniquePairs = new HashSet<>();\n        Map<Integer, Integer> freq = new HashMap<>();\n\n        if (k == 0) {\n            for (int num : nums)\n                freq.put(num, freq.getOrDefault(num, 0) + 1);\n\n            int count = 0;\n            for (int value : freq.values())\n                if (value > 1)\n                    count++;\n            return count;\n        } else {\n            for (int num : nums)\n                seen.add(num);\n\n            for (int num : seen)\n                if (seen.contains(num + k))\n                    uniquePairs.add(num);\n\n            return uniquePairs.size();\n        }\n    }\n}",
        "cpp": "#include <unordered_set>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findPairs(vector<int>& nums, int k) {\n        if (k < 0) return 0;\n\n        unordered_set<int> seen;\n        unordered_set<int> uniquePairs;\n        unordered_map<int, int> freq;\n\n        if (k == 0) {\n            for (int num : nums)\n                freq[num]++;\n            int count = 0;\n            for (auto& it : freq)\n                if (it.second > 1)\n                    count++;\n            return count;\n        } else {\n            for (int num : nums)\n                seen.insert(num);\n            for (int num : seen)\n                if (seen.count(num + k))\n                    uniquePairs.insert(num);\n            return uniquePairs.size();\n        }\n    }\n};"
      }
    }
  ],
  "examples": [
    {
      "input": {
        "values": [4, 2, 5, 2, 6],
        "target_diff": 3
      },
      "output": 1,
      "explanation": "Valid unique pair: (2, 5). Duplicates and reverse pairs are counted once."
    },
    {
      "input": {
        "values": [10, 20, 30, 40, 50],
        "target_diff": 10
      },
      "output": 4,
      "explanation": "Valid pairs: (10,20), (20,30), (30,40), (40,50)"
    },
    {
      "input": {
        "values": [7, 7, 7, 7],
        "target_diff": 0
      },
      "output": 1,
      "explanation": "One unique identical value pair: (7,7)"
    }
  ],
  "constraints": {
    "1 <= values.length <= 100000": true,
    "0 <= target_diff <= 1000000000": true,
    "-10^9 <= values[i] <= 10^9": true
  },
  "edge_cases": [
    {
      "input": {
        "values": [1, 2, 3],
        "target_diff": 4
      },
      "output": 0,
      "reason": "No valid pairs exist with the given difference."
    },
    {
      "input": {
        "values": [1, 1],
        "target_diff": 0
      },
      "output": 1,
      "reason": "Only one duplicate pair exists."
    },
    {
      "input": {
        "values": [1],
        "target_diff": 0
      },
      "output": 0,
      "reason": "Single element can't form a pair."
    }
  ],
  "test_cases": [
    {
      "id": "tc1",
      "input": {
        "values": [1, 3, 1, 5, 4],
        "target_diff": 0
      },
      "expected_output": 1
    },
    {
      "id": "tc2",
      "input": {
        "values": [1, 2, 3, 4, 5],
        "target_diff": 2
      },
      "expected_output": 3
    }
  ],
  "notes": {
    "pair_uniqueness": "Store pairs in sorted order to avoid counting (a,b) and (b,a) separately.",
    "frequency_map": "Used only when k == 0 to find duplicates."
  },
  "hints": [
    "What if you use a set to track which numbers you’ve seen?",
    "Try storing sorted pairs to prevent duplicates.",
    "Think about how you would handle k = 0 vs. k > 0."
  ],
  "follow_up": [
    "Can you return the actual list of unique pairs instead of just the count?",
    "What changes if you're asked to return all indices forming valid pairs?",
    "How would this change if the array were sorted or streamed?"
  ],
  "tags": ["Hash Map", "Two Pointers", "Sorting", "Edge Cases", "Array"]
}
