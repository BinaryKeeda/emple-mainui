{
  "title": "Reverse Linked List",
  "description": "Given the starting node ‘listHead’ of a singly linked list, reverse the order of its nodes and return the new head of the reversed list.",
  "metadata": {
    "difficulty": "Easy",
    "tags": ["Linked List", "Two Pointers", "Recursion", "In-Place"],
    "author": "Vaibhav Chauhan",
    "created_at": "2025-07-09",
    "updated_at": "2025-07-09",
    "source": "BinaryKeeda DSA Sheet"
  },
  "approaches": [
    {
      "category": "Brute Force",
      "algorithm": "Value Collection and Rebuilding",
      "description": "Traverse the list to collect values in an array, reverse the array, and rebuild the linked list with new nodes using the reversed values.",
      "steps": [
        "Traverse the linked list and collect all node values into a list/vector.",
        "Reverse the list/vector.",
        "Create a new linked list using the reversed list of values.",
        "Return the head of the newly constructed list."
      ],
      "time_complexity": "O(n)",
      "space_complexity": "O(n)",
      "code": {
        "java": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        if (head == null) return null;\n        List<Integer> values = new ArrayList<>();\n        ListNode curr = head;\n        while (curr != null) {\n            values.add(curr.val);\n            curr = curr.next;\n        }\n        Collections.reverse(values);\n        ListNode dummy = new ListNode(0);\n        ListNode newCurr = dummy;\n        for (int val : values) {\n            newCurr.next = new ListNode(val);\n            newCurr = newCurr.next;\n        }\n        return dummy.next;\n    }\n}",
        "cpp": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        if (!head) return nullptr;\n        vector<int> values;\n        ListNode* curr = head;\n        while (curr) {\n            values.push_back(curr->val);\n            curr = curr->next;\n        }\n        reverse(values.begin(), values.end());\n        ListNode* dummy = new ListNode(0);\n        ListNode* newCurr = dummy;\n        for (int val : values) {\n            newCurr->next = new ListNode(val);\n            newCurr = newCurr->next;\n        }\n        return dummy->next;\n    }\n}"
      }
    },
    {
      "category": "Optimal",
      "algorithm": "In-Place Reversal Using Pointers",
      "description": "Use three pointers (prev, curr, next) to reverse the pointers of each node in-place without extra memory.",
      "steps": [
        "Initialize prev as null and curr as head.",
        "Iterate while curr is not null.",
        "Store next = curr.next.",
        "Reverse the link: curr.next = prev.",
        "Move prev = curr and curr = next.",
        "At the end, prev will be the new head. Return it."
      ],
      "time_complexity": "O(n)",
      "space_complexity": "O(1)",
      "code": {
        "java": "class Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n}",
        "cpp": "class Solution {\npublic:\n    ListNode* reverseList(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n}"
      }
    }
  ],
  "examples": [
    {
      "input": [10, 20, 30, 40, 50],
      "output": [50, 40, 30, 20, 10],
      "explanation": "Original: 10 → 20 → 30 → 40 → 50 → null, Reversed: 50 → 40 → 30 → 20 → 10 → null"
    },
    {
      "input": [5, 8],
      "output": [8, 5],
      "explanation": "Original: 5 → 8 → null, Reversed: 8 → 5 → null"
    },
    {
      "input": [],
      "output": [],
      "explanation": "Empty list remains empty after reversal"
    }
  ],
  "constraints": {
    "1 <= Number of nodes <= 10^5": true,
    "ListNode value range": "-10^9 <= Node.val <= 10^9"
  },
  "edge_cases": [
    {
      "input": [],
      "output": [],
      "reason": "Edge case for an empty list"
    },
    {
      "input": [100],
      "output": [100],
      "reason": "Single element list should return the same node"
    }
  ],
  "test_cases": [
    {
      "id": "tc1",
      "input": [1, 2, 3],
      "expected_output": [3, 2, 1]
    },
    {
      "id": "tc2",
      "input": [99],
      "expected_output": [99]
    }
  ],
  "notes": {
    "memory_advantage": "Optimal approach avoids auxiliary space by reversing in-place.",
    "application": "This technique is used in problems involving reversing segments or sublists, such as reversing a sublist between two positions."
  },
  "hints": [
    "Can you reverse the links instead of copying values?",
    "How can you reverse the list without extra memory?"
  ],
  "follow_up": [
    "Can you reverse only the first k nodes of the linked list?",
    "How would you reverse a linked list recursively?",
    "How to reverse in groups of size k?"
  ],
  "tags": ["Linked List", "Two Pointers", "Pointer Manipulation", "In-Place"]
}
